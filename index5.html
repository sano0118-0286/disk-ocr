<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Disk OCR (Mobile)</title>
  <style>
    :root { --b:#e6e6e6; --bg:#fff; --muted:#666; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background: var(--bg); }
    .wrap { padding: 12px; display: grid; gap: 10px; }
    .card { border:1px solid var(--b); border-radius:12px; padding:10px; }
    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .title { font-weight: 800; }
    .muted { color: var(--muted); font-size: 13px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    button { padding: 10px 12px; border-radius: 10px; border: 1px solid var(--b); background: #fff; }
    button:active { transform: scale(0.99); }
    button:disabled { opacity: 0.5; }
    .pill { display:inline-block; padding:2px 8px; border-radius:999px; font-size:12px; border:1px solid var(--b); }
    .ok { border-color:#cfe9d6; background:#f2fbf4; }
    .bad { border-color:#f0caca; background:#fff2f2; }

    .stage { position: relative; border-radius: 12px; overflow: hidden; background:#111; }
    video { width:100%; height:auto; display:block; }
    /* ROI 가이드 박스 */
    .roi {
      position:absolute;
      left: 10%;
      top: 35%;
      width: 80%;
      height: 30%;
      border: 2px solid rgba(255,255,255,0.8);
      border-radius: 10px;
      box-shadow: 0 0 0 9999px rgba(0,0,0,0.25);
      pointer-events:none;
    }
    .roi::after {
      content: "ROI";
      position:absolute;
      top:-22px; left:0;
      font-size:12px;
      color:#fff;
      opacity:0.85;
      background: rgba(0,0,0,0.35);
      padding: 2px 6px;
      border-radius: 999px;
    }

    table { width:100%; border-collapse: collapse; font-size: 14px; }
    th, td { border-bottom:1px solid #eee; padding: 8px; text-align:left; vertical-align: top; }
    th { font-weight: 700; }
    .small { font-size: 12px; color: var(--muted); }
  </style>
</head>
<body>
  <div class="wrap">

    <div class="card">
      <div class="row" style="justify-content:space-between">
        <div>
          <div class="title">Live OCR (SSD 라벨)</div>
          <div class="muted">모바일 카메라 → OCR → 조건 충족 시 자동으로 표에 추가</div>
        </div>
        <span id="statusPill" class="pill bad">대기중…</span>
      </div>
    </div>

    <div class="card">
      <div class="stage">
        <video id="video" playsinline autoplay muted></video>
        <div class="roi"></div>
      </div>

      <canvas id="canvas" style="display:none"></canvas>

      <div class="row" style="margin-top:10px">
        <button id="btnStart">카메라 시작</button>
        <button id="btnStop" disabled>정지</button>
        <button id="btnAddManual" disabled>수동 추가</button>
        <button id="btnCopyTSV">마지막 행 복사(TSV)</button>
        <button id="btnClear">표 비우기</button>
      </div>

      <div class="row muted" style="margin-top:8px">
        <div>OCR 텍스트: <span id="ocrText" class="mono">-</span></div>
      </div>
      <div class="row muted">
        <div>score: <span id="ocrScore" class="mono">-</span></div>
        <div>conf: <span id="ocrConf" class="mono">-</span></div>
        <div>stableHits: <span id="stableHits" class="mono">0</span></div>
        <div>cooldown: <span id="cooldown" class="mono">0</span>ms</div>
      </div>
      <div class="small" style="margin-top:6px">
        자동추가 조건: <span class="mono">score ≥ 2</span>, <span class="mono">conf ≥ 0.30</span>, 쿨다운 <span class="mono">2000ms</span>, stableHits <span class="mono">1</span>
      </div>
    </div>

    <div class="card">
      <div class="row" style="justify-content:space-between">
        <div class="title">누적 테이블</div>
        <div class="muted">자동추가 쿨다운으로 연속 누적 방지</div>
      </div>
      <table>
        <thead>
          <tr>
            <th style="width:44px">#</th>
            <th>Text</th>
            <th style="width:70px">score</th>
            <th style="width:70px">conf</th>
            <th style="width:86px">Time</th>
          </tr>
        </thead>
        <tbody id="tbody"></tbody>
      </table>
    </div>

  </div>

  <!-- OCR 엔진: Tesseract.js -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

  <script>
    /*****************************************************************
     * ✅ 요청 반영 설정
     *****************************************************************/
    const STABLE_HITS_REQUIRED = 1;      // (요청) 1로 변경
    const AUTO_ADD_SCORE_MIN   = 2;      // (요청) 유지: score >= 2
    const AUTO_ADD_CONF_MIN    = 0.30;   // (요청) conf는 낮춰도 OK (더 낮추려면 0.25 등)
    const AUTO_ADD_COOLDOWN_MS = 2000;   // (요청) 자동추가 쿨다운 유지(연속 누적 방지)

    // 모바일 성능/발열 고려 (너무 빠르면 렉/발열)
    const OCR_INTERVAL_MS = 550;

    // ROI 영역 (비디오 대비 비율) — CSS ROI 가이드와 동일하게 맞춤
    const ROI = { x: 0.10, y: 0.35, w: 0.80, h: 0.30 };

    /*****************************************************************
     * DOM
     *****************************************************************/
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });

    const statusPill = document.getElementById('statusPill');
    const ocrTextEl  = document.getElementById('ocrText');
    const ocrScoreEl = document.getElementById('ocrScore');
    const ocrConfEl  = document.getElementById('ocrConf');
    const stableHitsEl = document.getElementById('stableHits');
    const cooldownEl = document.getElementById('cooldown');

    const btnStart = document.getElementById('btnStart');
    const btnStop = document.getElementById('btnStop');
    const btnAddManual = document.getElementById('btnAddManual');
    const btnCopyTSV = document.getElementById('btnCopyTSV');
    const btnClear = document.getElementById('btnClear');

    const tbody = document.getElementById('tbody');

    /*****************************************************************
     * 상태
     *****************************************************************/
    let stream = null;
    let running = false;
    let worker = null;
    let ocrTimer = null;

    let lastCandidateText = '';
    let stableHits = 0;

    let lastAutoAddAt = 0;

    const rows = [];
    let lastResult = null; // 수동추가용

    /*****************************************************************
     * 유틸
     *****************************************************************/
    function setStatus(ok, text) {
      statusPill.textContent = text;
      statusPill.classList.toggle('ok', !!ok);
      statusPill.classList.toggle('bad', !ok);
    }

    function pad2(n){ return String(n).padStart(2,'0'); }
    function nowStr() {
      const d = new Date();
      return `${pad2(d.getHours())}:${pad2(d.getMinutes())}:${pad2(d.getSeconds())}`;
    }

    function escapeHtml(s) {
      return String(s)
        .replaceAll('&','&amp;')
        .replaceAll('<','&lt;')
        .replaceAll('>','&gt;')
        .replaceAll('"','&quot;')
        .replaceAll("'",'&#039;');
    }

    function normalizeText(text) {
      if (!text) return '';
      return text
        .replace(/\s+/g, ' ')
        .replace(/[\u200B-\u200D\uFEFF]/g, '') // zero-width 제거
        .trim();
    }

    // score 계산: “현실적으로 완화” + score>=2 유지
    // - 길이/구조/키워드/숫자 조합 등으로 간단 스코어링
    function computeScore(text) {
      const t = normalizeText(text);
      if (!t) return 0;

      let score = 0;

      // 1) 길이 기반
      if (t.length >= 6) score += 1;
      if (t.length >= 10) score += 1;

      // 2) SSD 라벨에서 흔한 키워드
      if (/(S\/?N|SN|SERIAL|P\/?N|PN|MODEL|CAPACITY|GB|TB|NVME|SATA|SSD)/i.test(t)) score += 1;

      // 3) 숫자 포함
      if (/\d/.test(t)) score += 1;

      // 4) 영숫자 혼합이면 가점(시리얼/파트넘버 형태)
      if (/[A-Z]/i.test(t) && /\d/.test(t)) score += 1;

      // 너무 과대평가 방지: 상한
      return Math.min(score, 5);
    }

    function updateDebug(result) {
      const txt = result?.text ?? '-';
      ocrTextEl.textContent = txt ? txt : '-';
      ocrScoreEl.textContent = (result?.score ?? '-');
      ocrConfEl.textContent  = (typeof result?.conf === 'number') ? result.conf.toFixed(2) : (result?.conf ?? '-');

      stableHitsEl.textContent = String(stableHits);

      const remain = Math.max(0, (lastAutoAddAt + AUTO_ADD_COOLDOWN_MS) - Date.now());
      cooldownEl.textContent = String(remain);
    }

    function renderTable() {
      tbody.innerHTML = rows.map((r, idx) => `
        <tr>
          <td>${idx + 1}</td>
          <td class="mono">${escapeHtml(r.text)}</td>
          <td class="mono">${r.score}</td>
          <td class="mono">${(typeof r.conf === 'number') ? r.conf.toFixed(2) : r.conf}</td>
          <td class="mono">${r.time}</td>
        </tr>
      `).join('');
    }

    function addRow(result, reason) {
      const text = normalizeText(result.text);
      if (!text) return;

      rows.push({
        text,
        score: result.score ?? '',
        conf: result.conf ?? '',
        time: nowStr(),
        reason
      });
      renderTable();
    }

    function canAutoAdd(result) {
      if (!result) return false;

      const text = normalizeText(result.text);
      if (!text) return false;

      // (요청) score>=2 유지
      if ((result.score ?? 0) < AUTO_ADD_SCORE_MIN) return false;

      // (요청) conf는 낮춰도 OK → 낮춘 임계값 적용
      if ((result.conf ?? 0) < AUTO_ADD_CONF_MIN) return false;

      // (요청) 쿨다운 유지
      const now = Date.now();
      if (now - lastAutoAddAt < AUTO_ADD_COOLDOWN_MS) return false;

      // (요청) stable hits 1로 완화
      if (text === lastCandidateText) stableHits++;
      else {
        lastCandidateText = text;
        stableHits = 1;
      }

      return stableHits >= STABLE_HITS_REQUIRED;
    }

    /*****************************************************************
     * 카메라
     *****************************************************************/
    async function startCamera() {
      if (stream) return;
      try {
        stream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: { ideal: 'environment' },
            width:  { ideal: 1280 },
            height: { ideal: 720 }
          },
          audio: false
        });
        video.srcObject = stream;
        await video.play();
        setStatus(true, '카메라 ON');
      } catch (e) {
        console.error(e);
        setStatus(false, '카메라 실패');
        alert('카메라 권한/HTTPS 환경을 확인해 주세요.');
      }
    }

    function stopCamera() {
      if (!stream) return;
      stream.getTracks().forEach(t => t.stop());
      stream = null;
      setStatus(false, '대기중…');
    }

    /*****************************************************************
     * OCR (Tesseract)
     *****************************************************************/
    async function initWorker() {
      if (worker) return worker;
      worker = await Tesseract.createWorker('eng'); // 필요하면 언어 추가 가능
      // SSD 라벨 특성상 대문자/숫자 위주로 편향
      await worker.setParameters({
        tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_/.: ',
      });
      return worker;
    }

    function captureRoiToCanvas() {
      if (!video.videoWidth || !video.videoHeight) return false;

      const vw = video.videoWidth;
      const vh = video.videoHeight;

      const rx = Math.floor(vw * ROI.x);
      const ry = Math.floor(vh * ROI.y);
      const rw = Math.floor(vw * ROI.w);
      const rh = Math.floor(vh * ROI.h);

      canvas.width = rw;
      canvas.height = rh;

      ctx.drawImage(video, rx, ry, rw, rh, 0, 0, rw, rh);

      // 약한 전처리(가볍게 대비 올리기) — 모바일 성능 고려해서 최소만
      const img = ctx.getImageData(0, 0, rw, rh);
      const data = img.data;
      for (let i = 0; i < data.length; i += 4) {
        const r = data[i], g = data[i+1], b = data[i+2];
        // 그레이스케일
        let y = (r * 0.299 + g * 0.587 + b * 0.114);
        // 대비 약간
        y = Math.min(255, Math.max(0, (y - 128) * 1.15 + 128));
        data[i] = data[i+1] = data[i+2] = y;
      }
      ctx.putImageData(img, 0, 0);

      return true;
    }

    async function runOcrOnce() {
      const ok = captureRoiToCanvas();
      if (!ok) return null;

      const w = await initWorker();

      // recognize
      const { data } = await w.recognize(canvas);
      const text = normalizeText(data.text || '');

      // Tesseract confidence: 0~100(대체로) → 0~1로 정규화
      const confRaw = (typeof data.confidence === 'number') ? data.confidence : 0;
      const conf = Math.max(0, Math.min(1, confRaw / 100));

      const score = computeScore(text);

      return { text, score, conf };
    }

    async function ocrLoopTick() {
      if (!running) return;

      let result = null;
      try {
        result = await runOcrOnce();
      } catch (e) {
        console.error(e);
      }

      lastResult = result;
      updateDebug(result);

      if (canAutoAdd(result)) {
        addRow(result, 'auto');
        lastAutoAddAt = Date.now();
        // 자동추가 직후: 같은 텍스트 연속 누적 방지
        stableHits = 0;
      }

      ocrTimer = setTimeout(ocrLoopTick, OCR_INTERVAL_MS);
    }

    async function startLoop() {
      if (running) return;
      running = true;
      setStatus(true, 'OCR 실행중');
      btnStart.disabled = true;
      btnStop.disabled = false;
      btnAddManual.disabled = false;
      await initWorker();
      ocrLoopTick();
    }

    async function stopLoop() {
      running = false;
      if (ocrTimer) clearTimeout(ocrTimer);
      ocrTimer = null;

      btnStart.disabled = false;
      btnStop.disabled = true;
      btnAddManual.disabled = true;

      // 워커는 유지(재시작 빠르게). 완전 종료 원하면 아래 주석 해제:
      // if (worker) { await worker.terminate(); worker = null; }

      setStatus(!!stream, stream ? '카메라 ON' : '대기중…');
    }

    /*****************************************************************
     * 버튼 핸들러
     *****************************************************************/
    btnStart.addEventListener('click', async () => {
      await startCamera();
      await startLoop();
    });

    btnStop.addEventListener('click', async () => {
      await stopLoop();
      stopCamera();
    });

    btnAddManual.addEventListener('click', () => {
      if (!lastResult || !normalizeText(lastResult.text)) {
        alert('추가할 텍스트가 없습니다.');
        return;
      }
      addRow(lastResult, 'manual');
    });

    btnCopyTSV.addEventListener('click', async () => {
      if (!rows.length) {
        alert('복사할 행이 없습니다.');
        return;
      }
      const r = rows[rows.length - 1];
      const tsv = `${r.text}\t${r.score}\t${(typeof r.conf === 'number') ? r.conf.toFixed(2) : r.conf}\t${r.time}`;

      try {
        await navigator.clipboard.writeText(tsv);
        alert('마지막 행 TSV 복사 완료');
      } catch (e) {
        // iOS/권한 이슈 대비 폴백
        const ta = document.createElement('textarea');
        ta.value = tsv;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        ta.remove();
        alert('마지막 행 TSV 복사 완료(폴백)');
      }
    });

    btnClear.addEventListener('click', () => {
      rows.length = 0;
      renderTable();
      lastCandidateText = '';
      stableHits = 0;
      lastAutoAddAt = 0;
      lastResult = null;
      updateDebug(null);
    });

    /*****************************************************************
     * 초기 상태
     *****************************************************************/
    setStatus(false, '대기중…');
    updateDebug(null);
  </script>
</body>
</html>

