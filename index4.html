<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Live SSD OCR → Excel</title>
  <style>
    body { font-family: system-ui,-apple-system,Arial; margin: 16px; }
    h1 { font-size: clamp(22px, 6vw, 34px); line-height: 1.15; margin: 8px 0 12px; }

    .row { display:flex; gap:16px; flex-wrap:wrap; align-items:flex-start; }

    /* ✅ camWrap 자체의 높이를 고정: 카메라 ON/OFF, 메타데이터 로드 전/후에도 레이아웃 불변 */
    .camWrap {
      position: relative;
      width: 360px;
      max-width: 100%;
      aspect-ratio: 3 / 4;     /* ✅ 고정 비율 */
      border-radius: 12px;
      overflow: hidden;        /* ✅ ROI 마스크가 밖으로 새지 않게 */
      background:#111;
      border:1px solid #ddd;
    }

    /* ✅ 비디오는 camWrap에 '절대'로 꽉 채움: 레이아웃 변화로 ROI가 흔들리지 않음 */
    video {
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      object-fit: cover;
      display:block;
      background:#111;
    }

    .roi{
      position:absolute;
      inset:0;
      pointer-events:none;
      display:flex;
      align-items:center;
      justify-content:center;
      z-index: 2;
    }

    .frame{
      width: 78%;
      height: 38%;
      border: 3px solid rgba(255,255,255,.9);
      border-radius: 12px;
      box-shadow: 0 0 0 9999px rgba(0,0,0,.35);
    }

    .controls { display:flex; gap:10px; flex-wrap:wrap; margin:10px 0; }
    .controls button { flex: 1 1 auto; min-width: 120px; }

    button {
      padding:10px 14px; border:0; border-radius:10px;
      background:#111; color:#fff; cursor:pointer;
    }
    button.secondary { background:#444; }
    button:disabled { opacity:.5; cursor:not-allowed; }

    .status { margin: 8px 0; color:#333; }
    table { border-collapse: collapse; width: min(900px, 100%); }
    th, td { border:1px solid #ddd; padding:8px; font-size:14px; }
    th { background:#f6f6f6; text-align:left; }
    td .mini { font-size: 12px; color:#666; }
    .pill { display:inline-block; padding:4px 8px; border-radius:999px; background:#eef; margin-right:6px; font-size:12px; }
    .small { font-size:12px; color:#666; line-height:1.4; max-width: 520px;}
    canvas { display:none; }
    pre { white-space: pre-wrap; background:#f6f6f6; padding:10px; border-radius:10px; max-width: 520px; }
  </style>
</head>
<body>
  <h1>라이브 OCR (SSD 라벨) → 표 누적 → 엑셀 다운로드</h1>
  <div class="small">
    ROI(흰 사각 프레임)에 <b>시리얼/PN/용량</b>이 보이도록 맞추면 OCR 수행 후 표에 추가됩니다.
    <br/>정확도는 조명/반사/초점에 크게 좌우됩니다(가까이, 반사 최소화, 글씨 선명하게).
  </div>

  <div class="row">
    <div style="width: 360px; max-width:100%;">
      <div class="camWrap" id="camWrap">
        <video id="video" autoplay playsinline webkit-playsinline muted></video>
        <!-- ✅ 카메라 ON/OFF와 무관하게 ROI는 camWrap 중앙에 고정 표시 -->
        <div class="roi"><div class="frame"></div></div>
        <canvas id="canvas"></canvas>
      </div>

      <div class="controls">
        <button id="btnStart">카메라 시작</button>
        <button id="btnStop" class="secondary" disabled>중지</button>
        <button id="btnToggle" class="secondary" disabled>자동인식 ON</button>
        <button id="btnAdd" class="secondary" disabled>현재 결과 추가</button>
      </div>

      <div class="status" id="status">대기중…</div>
      <div>
        <span class="pill">추출된 값</span>
        <span id="liveFields"></span>
      </div>
      <pre id="rawText">(원문 OCR 텍스트가 여기에 표시됩니다)</pre>
    </div>

    <div style="min-width:320px; flex: 1;">
      <div class="controls">
        <button id="btnCopyRow" class="secondary" disabled>마지막 행 복사(TSV)</button>
        <button id="btnDownload" disabled>엑셀(.xlsx) 다운로드</button>
        <button id="btnClear" class="secondary">전체 삭제</button>
      </div>

      <table id="tbl">
        <thead>
          <tr>
            <th>#</th>
            <th>Serial Number</th>
            <th>Capacity</th>
            <th>Part Number</th>
            <th>Timestamp</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>

      <div class="small" style="margin-top:10px;">
        팁: 엑셀에 바로 붙여넣기 원하면 “마지막 행 복사(TSV)”를 누르고 엑셀에 붙여넣으면 열이 나뉩니다.
      </div>
    </div>
  </div>

  <!-- OCR: Tesseract.js -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
  <!-- Excel export: SheetJS -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.19.3/dist/xlsx.full.min.js"></script>

  <script>
    const video = document.getElementById("video");
    const canvas = document.getElementById("canvas");
    const statusEl = document.getElementById("status");
    const rawTextEl = document.getElementById("rawText");
    const liveFieldsEl = document.getElementById("liveFields");
    const tbody = document.querySelector("#tbl tbody");

    const btnStart = document.getElementById("btnStart");
    const btnStop = document.getElementById("btnStop");
    const btnToggle = document.getElementById("btnToggle");
    const btnAdd = document.getElementById("btnAdd");
    const btnDownload = document.getElementById("btnDownload");
    const btnClear = document.getElementById("btnClear");
    const btnCopyRow = document.getElementById("btnCopyRow");

    let stream = null;
    let autoOn = false;

    // OCR worker
    let worker = null;
    let ocrBusy = false;
    let lastOcrAt = 0;

    // ✅ 자동추가 안정화 파라미터
    const OCR_INTERVAL_MS = 1600;          // OCR 실행 간격
    const AUTO_ADD_COOLDOWN_MS = 2500;     // ✅ 자동 추가 후 쿨다운(연속 누적 방지)
    const MIN_CONFIDENCE = 35;             // ✅ 변별력: 신뢰도 낮으면 자동추가 금지(수치 조절 가능)
    const STABLE_HITS_REQUIRED = 2;        // ✅ 같은 결과 2번 연속이면 "확정"

    let lastAutoAddAt = 0;                 // 마지막 자동추가 시각
    let lastCandidateKey = "";
    let stableHits = 0;

    let live = { serial:null, capacity:null, partNumber:null, raw:"", conf:null };

    const rows = [];

    // ---- 유틸 ----
    function escapeHtml(s){ return (s||"").replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }
    function escapeAttr(s){ return escapeHtml(s).replace(/"/g,'&quot;'); }

    // ---- 파서/클리너(오탐 감소) ----
    function normalize(text) {
      return (text || "")
        .replace(/[|]/g,"I")
        .replace(/[“”]/g,'"')
        .replace(/[‘’]/g,"'")
        .replace(/\s+/g," ")
        .trim();
    }

    function cleanToken(tok) {
      return (tok || "")
        .toUpperCase()
        .replace(/[^A-Z0-9\-]/g, "")  // 허용 문자만
        .trim();
    }

    function isLikelyGarbage(tok) {
      if (!tok) return true;
      // 너무 짧거나, 전부 숫자(용량/날짜 오탐 가능)거나, 같은 문자 반복 등 배제
      if (tok.length < 8) return true;
      if (/^\d+$/.test(tok)) return true;
      if (/^(0+|1+|2+|3+|4+|5+|6+|7+|8+|9+)$/.test(tok)) return true;
      // 흔한 오탐 단어(필요시 추가)
      if (["SERIAL","SN","SNL","PN","PARTNO","PART","MODEL","MADEIN"].includes(tok)) return true;
      return false;
    }

    function parseSSDInfo(text) {
      const t = normalize(text);

      // 용량
      const cap = t.match(/\b(\d{2,4})\s?(GB|TB)\b/i);

      // Serial: 키워드 기반 우선
      const sn1 = t.match(/\b(S\/?N|SN|SERIAL|SER\.?)\s*[:#]?\s*([A-Z0-9\-]{6,})\b/i);

      // Part Number
      const pn1 = t.match(/\b(P\/?N|PN|PART\s?NO\.?)\s*[:#]?\s*([A-Z0-9\-]{4,})\b/i);

      // fallback: 길게 나온 토큰들 중 후보 찾기(가비지 필터링)
      const tokens = t.split(" ").map(cleanToken).filter(Boolean);

      let serial = sn1 ? cleanToken(sn1[2]) : null;
      let partNumber = pn1 ? cleanToken(pn1[2]) : null;

      // fallback 후보(단, 가비지 제거)
      if (!serial) {
        const cand = tokens.find(x => !isLikelyGarbage(x) && x.length >= 10);
        serial = cand || null;
      }
      if (serial && isLikelyGarbage(serial)) serial = null;

      if (partNumber && partNumber.length < 5) partNumber = null;

      // capacity 정규화
      let capacity = null;
      if (cap) {
        const num = cap[1];
        const unit = cap[2].toUpperCase();
        capacity = `${num}${unit}`;
      }

      return { serial, capacity, partNumber, raw: text };
    }

    function renderLive() {
      const parts = [];
      if (live.serial) parts.push(`<span class="pill">SN: ${escapeHtml(live.serial)}</span>`);
      if (live.capacity) parts.push(`<span class="pill">CAP: ${escapeHtml(live.capacity)}</span>`);
      if (live.partNumber) parts.push(`<span class="pill">PN: ${escapeHtml(live.partNumber)}</span>`);
      if (typeof live.conf === "number") parts.push(`<span class="pill">CONF: ${live.conf.toFixed(0)}</span>`);
      if (!parts.length) parts.push(`<span class="mini">추출된 값 없음</span>`);
      liveFieldsEl.innerHTML = parts.join(" ");
      btnAdd.disabled = !(live.serial || live.capacity || live.partNumber);
    }

    function addRowFromLive(reason = "manual") {
      const ts = new Date();
      const row = {
        serial: live.serial || "",
        capacity: live.capacity || "",
        partNumber: live.partNumber || "",
        timestamp: ts.toISOString()
      };

      // 완전 빈 값이면 추가 금지
      if (!row.serial && !row.capacity && !row.partNumber) {
        statusEl.textContent = "추가할 값이 없습니다.";
        return;
      }

      // 중복 방지
      const last = rows[rows.length-1];
      if (last && last.serial===row.serial && last.capacity===row.capacity && last.partNumber===row.partNumber) {
        statusEl.textContent = "같은 값이 연속으로 인식되어 추가하지 않았습니다.";
        return;
      }

      rows.push(row);
      const idx = rows.length;

      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${idx}</td>
        <td>
          ${escapeHtml(row.serial)}
          <div class="mini"><button data-copy="${escapeAttr(row.serial)}" class="secondary" style="padding:6px 10px;border-radius:8px;">복사</button></div>
        </td>
        <td>
          ${escapeHtml(row.capacity)}
          <div class="mini"><button data-copy="${escapeAttr(row.capacity)}" class="secondary" style="padding:6px 10px;border-radius:8px;">복사</button></div>
        </td>
        <td>
          ${escapeHtml(row.partNumber)}
          <div class="mini"><button data-copy="${escapeAttr(row.partNumber)}" class="secondary" style="padding:6px 10px;border-radius:8px;">복사</button></div>
        </td>
        <td>${escapeHtml(row.timestamp)}</td>
      `;
      tbody.appendChild(tr);

      btnDownload.disabled = rows.length === 0;
      btnCopyRow.disabled = rows.length === 0;

      if (reason === "auto") lastAutoAddAt = Date.now();
      statusEl.textContent = (reason === "auto") ? `자동 추가됨 (#${idx})` : `행 추가됨 (#${idx})`;
    }

    // ---- ROI 캡처 ----
    function captureROI() {
      const vw = video.videoWidth, vh = video.videoHeight;
      if (!vw || !vh) return null;

      const roiW = Math.floor(vw * 0.78);
      const roiH = Math.floor(vh * 0.38);
      const roiX = Math.floor((vw - roiW) / 2);
      const roiY = Math.floor((vh - roiH) / 2);

      canvas.width = roiW;
      canvas.height = roiH;
      const ctx = canvas.getContext("2d", { willReadFrequently: true });

      ctx.drawImage(video, roiX, roiY, roiW, roiH, 0, 0, roiW, roiH);

      // 전처리(간단 threshold)
      const img = ctx.getImageData(0,0,roiW,roiH);
      const data = img.data;
      const thr = 150;
      for (let i=0;i<data.length;i+=4) {
        const gray = data[i]*0.3 + data[i+1]*0.59 + data[i+2]*0.11;
        const v = gray > thr ? 255 : 0;
        data[i]=data[i+1]=data[i+2]=v;
      }
      ctx.putImageData(img,0,0);

      return canvas.toDataURL("image/png");
    }

    // ---- OCR ----
    async function ensureWorker() {
      if (worker) return;
      worker = await Tesseract.createWorker("eng", 1, {
        logger: m => {
          if (m.status === "recognizing text") {
            statusEl.textContent = `OCR… ${(m.progress*100).toFixed(0)}%`;
          }
        }
      });
      await worker.setParameters({
        tessedit_char_whitelist: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-/:# .",
        // 필요시 PSM 조정 가능(라벨 성격에 따라 6/7/11 테스트)
        // tessedit_pageseg_mode: "6",
      });
    }

    function explainCamError(e) {
      if (e && (e.name === "NotAllowedError" || e.name === "PermissionDeniedError")) {
        return "카메라 권한이 거부되었습니다. (인앱 브라우저면 Chrome/삼성인터넷에서 열어보세요)";
      }
      if (e && e.name === "NotFoundError") return "카메라를 찾을 수 없습니다.";
      if (e && e.name === "NotReadableError") return "카메라를 다른 앱이 사용 중입니다.";
      return "카메라 접근 실패: " + (e?.message || e);
    }

    // ✅ 자동추가 조건 평가(안정화 + 쿨다운 + 변별력)
    function considerAutoAdd(parsed, conf) {
      const now = Date.now();

      // 쿨다운 중이면 자동추가 금지
      if (now - lastAutoAddAt < AUTO_ADD_COOLDOWN_MS) return;

      // confidence 낮으면 자동추가 금지(수동 추가는 가능)
      if (typeof conf === "number" && conf < MIN_CONFIDENCE) return;

      // 최소 조건: SN/PN/CAP 중 2개 이상
      const score = [parsed.serial, parsed.partNumber, parsed.capacity].filter(Boolean).length;
      if (score < 2) {
        // 안정화 카운터 리셋
        lastCandidateKey = "";
        stableHits = 0;
        return;
      }

      const key = `${parsed.serial||""}|${parsed.capacity||""}|${parsed.partNumber||""}`;

      if (key === lastCandidateKey) stableHits += 1;
      else {
        lastCandidateKey = key;
        stableHits = 1;
      }

      if (stableHits >= STABLE_HITS_REQUIRED) {
        addRowFromLive("auto");
        stableHits = 0; // 추가 후 리셋
        lastCandidateKey = "";
      }
    }

    async function tick() {
      if (!autoOn) return;

      const now = Date.now();
      if (ocrBusy || (now - lastOcrAt) < OCR_INTERVAL_MS) {
        requestAnimationFrame(tick);
        return;
      }

      const img = captureROI();
      if (!img) { requestAnimationFrame(tick); return; }

      try {
        ocrBusy = true;
        lastOcrAt = now;

        await ensureWorker();
        const res = await worker.recognize(img);

        const text = (res.data.text || "").trim();
        const conf = (typeof res.data.confidence === "number") ? res.data.confidence : null;

        rawTextEl.textContent = text || "(인식된 텍스트 없음)";
        const parsed = parseSSDInfo(text);

        live = { ...parsed, raw: text, conf };
        renderLive();

        considerAutoAdd(parsed, conf);

        if (conf !== null && conf < MIN_CONFIDENCE) {
          statusEl.textContent = `신뢰도 낮음(CONF ${conf.toFixed(0)}). 프레임/초점/반사 조정 후 재시도.`;
        } else {
          statusEl.textContent = "자동 인식 중…";
        }

      } catch (e) {
        statusEl.textContent = "OCR 오류: " + e.message;
      } finally {
        ocrBusy = false;
        requestAnimationFrame(tick);
      }
    }

    // ---- UI ----
    btnStart.onclick = async () => {
      try {
        statusEl.textContent = "카메라 요청 중…";

        const preferred = { video: { facingMode: { ideal: "environment" } }, audio: false };
        const fallback  = { video: true, audio: false };

        try {
          stream = await navigator.mediaDevices.getUserMedia(preferred);
        } catch {
          stream = await navigator.mediaDevices.getUserMedia(fallback);
        }

        video.srcObject = stream;
        await video.play();

        btnStop.disabled = false;
        btnToggle.disabled = false;
        statusEl.textContent = "카메라 시작됨. ROI 프레임에 라벨 글씨를 맞추세요.";
      } catch (e) {
        statusEl.textContent = explainCamError(e);
      }
    };

    btnStop.onclick = async () => {
      autoOn = false;
      btnToggle.textContent = "자동인식 ON";
      btnAdd.disabled = true;
      btnStop.disabled = true;
      btnToggle.disabled = true;

      stableHits = 0;
      lastCandidateKey = "";

      if (stream) {
        stream.getTracks().forEach(t => t.stop());
        stream = null;
      }
      video.srcObject = null;

      if (worker) {
        await worker.terminate();
        worker = null;
      }
      statusEl.textContent = "중지됨.";
    };

    btnToggle.onclick = () => {
      autoOn = !autoOn;
      btnToggle.textContent = autoOn ? "자동인식 OFF" : "자동인식 ON";
      statusEl.textContent = autoOn ? "자동 인식 시작…" : "자동 인식 일시정지.";
      if (autoOn) requestAnimationFrame(tick);
    };

    btnAdd.onclick = () => addRowFromLive("manual");

    document.addEventListener("click", async (ev) => {
      const btn = ev.target.closest("button[data-copy]");
      if (!btn) return;
      const val = btn.getAttribute("data-copy") || "";
      try {
        await navigator.clipboard.writeText(val);
        statusEl.textContent = `복사됨: ${val}`;
      } catch {
        statusEl.textContent = "복사 실패(브라우저 권한/HTTPS 확인).";
      }
    });

    btnCopyRow.onclick = async () => {
      if (!rows.length) return;
      const r = rows[rows.length-1];
      const tsv = [r.serial, r.capacity, r.partNumber, r.timestamp].join("\t");
      try {
        await navigator.clipboard.writeText(tsv);
        statusEl.textContent = "마지막 행(TSV) 복사됨. 엑셀에 붙여넣으세요.";
      } catch {
        statusEl.textContent = "복사 실패(HTTPS/권한 확인).";
      }
    };

    btnDownload.onclick = () => {
      if (!rows.length) return;

      const wsData = [
        ["Serial Number", "Capacity", "Part Number", "Timestamp"],
        ...rows.map(r => [r.serial, r.capacity, r.partNumber, r.timestamp])
      ];

      const wb = XLSX.utils.book_new();
      const ws = XLSX.utils.aoa_to_sheet(wsData);
      XLSX.utils.book_append_sheet(wb, ws, "SSD");

      const filename = `ssd_ocr_${new Date().toISOString().slice(0,10)}.xlsx`;
      XLSX.writeFile(wb, filename);
      statusEl.textContent = "엑셀 파일 다운로드 완료.";
    };

    btnClear.onclick = () => {
      rows.length = 0;
      tbody.innerHTML = "";
      btnDownload.disabled = true;
      btnCopyRow.disabled = true;
      statusEl.textContent = "전체 삭제됨.";
    };

    renderLive();
  </script>
</body>
</html>

